# 연산자(operator)

## 산술 연산자

* 사칙 연산을 다루는 연산자

* 두 개의 피 연산자를 가지는 이항연산자

  * 항 : 해당 연산의 실행이 가능하기 위해 필요한 값이나 변수

* 피연산자들의 결합 뱡향은 왼쪽에서 오른쪽

  | 산술 연산자 |                            설명                            |
  | :---------: | :--------------------------------------------------------: |
  |      +      |         왼쪽의 피연산자에 오른쪽의 피연산자를 더함         |
  |      -      |         왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌         |
  |      *      |         왼쪽의 피연산자에 오른쪽의 피연산자를 곱함         |
  |      /      |         왼쪽의 피연산자를 오른쪽의 피연산자로 나눔         |
  |      %      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 나머지를 반환함 |
  |     **      |     왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 제곱함     |

  ```php
  $num_01 = 10;
  $num_02 = 4;
  
   
  echo "+ 연산자에 의한 결괏값은 ".($num_01 + $num_02)."입니다."; // + 연산자에 의한 결괏값은 14입니다.
  echo "- 연산자에 의한 결괏값은 ".($num_01 - $num_02)."입니다."; // - 연산자에 의한 결괏값은 6입니다.
  echo "* 연산자에 의한 결괏값은 ".($num_01 * $num_02)."입니다."; // * 연산자에 의한 결괏값은 40입니다.
  echo "/ 연산자에 의한 결괏값은 ".($num_01 / $num_02)."입니다."; // / 연산자에 의한 결괏값은 2.5입니다.
  echo "% 연산자에 의한 결괏값은 ".($num_01 % $num_02)."입니다.";     // % 연산자에 의한 결괏값은 2입니다.
  ```

* 연산자의 결합 방향(associativity)

  * 수식 내에 우선순위가 같은 연산자가 둘 이상 있을 때, 먼저 어느 연산을 수행할 것인가를 결정함
  * 같은 우선순위를 가지는 연산자가 둘 이상 있을 때에는 결합 순서에 따라 실행 순서가 결정됨

* 연산자의 우선순위(operator precedence)

  * 하나의 수식 내에 여러 연산자가 함께 등장할 때, 어느 연산자가 먼저 처리될 것인가를 결정함

  * 우선순위가 빠른 연산자가 가장 먼저 실행됨

  * 우선순위표

    | 우선순위 |   연산자   |                 설명                  | 결합 방향           |
    | :------: | :--------: | :-----------------------------------: | ------------------- |
    |    1     |    new     |              객체의 생성              |                     |
    |          |   clone    |              객체의 복제              |                     |
    |    2     |     []     |                 배열                  | 왼쪽에서 오른쪽으로 |
    |    3     |     ++     |              증가 연산자              |                     |
    |          |     --     |              감소 연산자              |                     |
    |    4     |   (타입)   |          타입 캐스트 연산자           |                     |
    |          |     ~      |            비트 NOT 연산자            |                     |
    |          |     -      |        음의 부호 (단항 연산자)        |                     |
    |    5     | instanceof |                 객체                  |                     |
    |    6     |     !      |            논리 NOT 연산자            | 오른쪽에서 왼쪽으로 |
    |    7     |     *      |              곱셈 연산자              | 왼쪽에서 오른쪽으로 |
    |          |     /      |             나눗셈 연산자             | 왼쪽에서 오른쪽으로 |
    |          |     %      |             나머지 연산자             | 왼쪽에서 오른쪽으로 |
    |    8     |     +      |              덧셈 연산자              | 왼쪽에서 오른쪽으로 |
    |          |     -      |              뺄셈 연산자              | 왼쪽에서 오른쪽으로 |
    |    9     |     <<     |        비트 왼쪽 시프트 연산자        | 왼쪽에서 오른쪽으로 |
    |          |    \>>     |       비트 오른쪽 시프트 연산자       | 왼쪽에서 오른쪽으로 |
    |    10    |     <      |        관계 연산자(보다 작은)         |                     |
    |          |     <=     |     관계 연산자(보다 작거나 같은)     |                     |
    |          |     >      |         관계 연산자(보다 큰)          |                     |
    |          |     >=     |     관계 연산자(보다 크거나 같은)     |                     |
    |          |     <>     |       관계 연산자(와 같지 않은)       |                     |
    |    11    |     ==     |         관계 연산자(와 같은)          |                     |
    |          |    ===     |    관계 연산자(와 같고 같은 타입)     |                     |
    |          |     !=     |       관계 연산자(와 같지 않은)       |                     |
    |          |    !==     | 관계 연산자(와 같지 않거나 다른 타입) |                     |
    |    12    |     &      |            비트 AND 연산자            | 왼쪽에서 오른쪽으로 |
    |    13    |     ^      |            비트 XOR 연산자            | 왼쪽에서 오른쪽으로 |
    |    14    |     \|     |            비트 OR 연산자             | 왼쪽에서 오른쪽으로 |
    |    15    |     &&     |            논리 AND 연산자            | 왼쪽에서 오른쪽으로 |
    |    16    |    \|\|    |            논리 OR 연산자             | 왼쪽에서 오른쪽으로 |
    |    17    |    ? :     |              삼항 연산자              | 오른쪽에서 왼쪽으로 |
    |    18    |     =      |              대입 연산자              | 오른쪽에서 왼쪽으로 |
    |          |     +=     |        복합 대입 연산자(덧셈)         | 오른쪽에서 왼쪽으로 |
    |          |     -=     |        복합 대입 연산자(뺄셈)         | 오른쪽에서 왼쪽으로 |
    |          |     *=     |        복합 대입 연산자(곱셈)         | 오른쪽에서 왼쪽으로 |
    |          |     /=     |       복합 대입 연산자(나눗셈)        | 오른쪽에서 왼쪽으로 |
    |          |     %=     |       복합 대입 연산자(나머지)        | 오른쪽에서 왼쪽으로 |
    |          |     .=     |     복합 대입 연산자(문자열 추가)     | 오른쪽에서 왼쪽으로 |
    |          |    <<==    |  복합 대입 연산자(비트 왼쪽 시프트)   | 오른쪽에서 왼쪽으로 |
    |          |   \>>==    | 복합 대입 연산자(비트 오른쪽 시프트)  | 오른쪽에서 왼쪽으로 |
    |          |     &=     |      복합 대입 연산자(비트 AND)       | 오른쪽에서 왼쪽으로 |
    |          |    \|=     |       복합 대입 연산자(비트 OR)       | 오른쪽에서 왼쪽으로 |
    |          |     ^=     |      복합 대입 연산자(비트 XOR)       | 오른쪽에서 왼쪽으로 |
    |    19    |    and     |            논리 AND 연산자            | 왼쪽에서 오른쪽으로 |
    |    20    |    xor     |            논리 XOR 연산자            | 왼쪽에서 오른쪽으로 |
    |    21    |     or     |            논리 OR 연산자             | 왼쪽에서 오른쪽으로 |
    |    22    |     ,      |              쉼표 연산자              | 왼쪽에서 오른쪽으로 |

## 대입 연산자

* 대입 연산자(assignment operator)

  * 변수에 값을 대입할 때 사용하는 이항 연산자

  * 피연산자들의 결합 방향 : 오른쪽에서 왼쪽

    | 대입 연산자 |                     설명                     |
    | :---------: | :------------------------------------------: |
    |      =      | 왼쪽의 피연산자에 오른쪽의 피연산자를 대입함 |

* 복합 대입 연산자

  * 대입 연산자와 산술 연산자 등을 결합한 연산자

  * 두 개의 피연산자를 가지는 이항 연산자

  * 피연산자들의 결합 방향 : 오른쪽에서 왼쪽

  * 연산자의 순서가 매우 중요함

    | 복합대입연산자 | 설명                                                         |
    | :------------: | ------------------------------------------------------------ |
    |       +=       | 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 왼쪽의 피연산자에 대입함 |
    |       -=       | 왼쪽의 피연산자에 오른쪽의 피연산자를 뺀 후, 왼쪽의 피연산자에 대입함 |
    |       *=       | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 왼쪽의 피연산자에 대입함 |
    |       /=       | 왼쪽의 피연산자에 오른쪽의 피연산자를 나눈 후, 왼쪽의 피연산자에 대입함 |
    |       %=       | 왼쪽의 피연산자에 오른쪽의 피연산자를 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입함 |
    |       .=       | 왼쪽의 피연산자의 문자열에 오른쪽의 피연산자의 문자열을 추가한 후, 왼쪽의 피연산자에 대입함 |
    |      <<=       | 왼쪽의 피연산자의 비트를 오른쪽의 피연산자만큼 전부 왼쪽으로 이동시킨 후, 그 결과를 왼쪽의 피연산자에 대입함 |
    |      \>>=      | 왼쪽의 피연산자의 비트를 부호를 유지하면서 오른쪽의 피연산자만큼 전부 오른쪽으로 이동시킨 후, 그 결과를 왼쪽의 피연산자에 대입함 |
    |       &=       | 왼쪽의 피연산자와 오른쪽의 피연산자의 논리식이 모두 true 면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함 |
    |      \|=       | 왼쪽의 피연산자나 오른쪽의 피연산자의 논리식 중 하나라도 true면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함 |
    |       ^=       | 왼쪽 피연산자의 논리식과 오른쪽 피연산자의 논리식이 서로 다르면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함 |

    ```php
    $num1 = 7;
    $num2 = 7;
    $num3 = 7;
    
    echo "- 연산자에 의한 결괏값은 ".($num1 = $num1 - 5)."입니다."; // - 연산자에 의한 결괏값은 2입니다.
    echo "-= 연산자에 의한 결괏값은 ".($num2 -= 5)."입니다.";         // -= 연산자에 의한 결괏값은 2입니다.
    echo "=- 연산자에 의한 결괏값은 ".($num3 =- 5)."입니다.";             // =- 연산자에 의한 결괏값은 -5입니다.
    ```

## 증감 연산자

* 증감 연산자(increment and decrement operator)

  * 피연산자를 1씩 증가 혹은 감소시킬 때 사용하는 연산자

  * 피연산자가 단 하나뿐인 단항 연산자

  * 해당 연산자가 피연산자의 어느 쪽에 위치하는 가에 따라 연산의 순서 및 결과가 달라짐

    | 증감 연산자 | 설명                                                       |
    | :---------: | ---------------------------------------------------------- |
    |   ++$var    | 먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 수행함    |
    |   $var++    | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴 |
    |   --$var    | 먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 수행함    |
    |   $var--    | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴 |

    ```php
    $num1 = 7;
    $num2 = 7;
    
    echo "++\\$num1 에 의한 결괏값은 ".(++$num1 - 5)."이고, 변수의 값은 {$num1}로 변했습니다.";
    // ++\7 에 의한 결괏값은 3이고, 변수의 값은 8로 변했습니다.
    echo "\\$num2++ 에 의한 결괏값은 ".($num2++ - 5)."이고, 변수의 값은 {$num2}로 변했습니다.";
    // \7++ 에 의한 결괏값은 2이고, 변수의 값은 8로 변했습니다.
    ```

* 증감 연산자의 연산 순서

  * 피연산자의 어느 쪽에 위치하는 가에 따라 연산의 순서가 달라짐

    ```php
    $x = 10;
    
    $y = $x-- + 5 + --$x;
    
     
    
    echo "변수 \\$x 의 값은 ".$x."이고, 변수 \\$y 의 값은 ".$y."으로 변경되었습니다.";
    // 변수 \8 의 값은 8이고, 변수 \23 의 값은 23으로 변경되었습니다.
    ```

    $x-- : 감소 연산자(decrement operator)가 피연산자의 뒤쪽에 위치하므로, 덧셈 연산(\$-- + 5)이 먼저 수행됨 => \$x의 값 : 9

    덧셈 연산 수행 후 `$y = 15 + --$x`

    --$x : 감소 연산자가 피연산자의 앞쪽에 위치하므로, 덧셈 연산보다 먼저 수행됨 => \$x의 값 : 8

    해당 연산 수행 후 `$y = 23`

## 비교 연산자

* 비교 연산자(comparison operator)

  * 피연산자 사이의 상대적인 크기를 판단하여, 참(true)과 거짓(false)을 반환함

  * 두 개의 피연산자를 가지는 이항 연산자

  * 피연산자들의 결합 방향 : 왼쪽에서 오른쪽

    | 비교 연산자 | 설명                                                         |
    | :---------: | ------------------------------------------------------------ |
    |     ==      | 왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 true 반환       |
    |     ===     | 왼쪽의 피연산자와 오른쪽의 피연산자가 같고, 같은 타입이면 true 반환 |
    |     !=      | 왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 true 반환  |
    |     <>      | 왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 true 반환  |
    |     !==     | 왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않거나, 타입이 다르면 true 반환 |
    |      <      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 true 반환     |
    |     <=      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 true 반환 |
    |      >      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 true 반환       |
    |     >=      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 true 반환 |

    * `!=`와 `<>`는 정확히 같은 동작을 하며, 연산자의 우선순위에서만 차이가 발생함

    ```php
    $num1 = 3; 		// 값 : 3 타입 : int
    $num2 = 3.0;	// 값 : 3 타입 : float
    $num3 = 3;
    
    var_dump($num1 == $num2);  // bool(true)
    var_dump($num1 === $num2); // bool(false)
    var_dump($num1 != $num3);  // bool(false)
    ```

* 다양한 타입의 비교 규칙

  |            피연산자1             |            피연산자2             | 비교 규칙                                                    |
  | :------------------------------: | :------------------------------: | ------------------------------------------------------------ |
  |            bool, null            |               모두               | 둘 다 boolean으로 변환한 후 비교함(false < true)             |
  | string, resource, integer, float | string, resource, integer, float | 숫자로 시작하는 문자열과 리소스는 숫자로 변환한 후 비교함    |
  |              object              |              object              | 내장 클래스는 자신의 비교 함수를 정의할 수 있으나, 다른 클래스끼리 비교할 수는 없음 |
  |              array               |              array               | 배열끼리의 비교는 같은 key를 가지는 값을 서로 비교함<br>이때 피연산자1 배열의 key가 피연산자2 배열에 존재하지 않으면 비교할 수 없으며, 배열 요소의 수가 적은 쪽이 작은 것으로 판단됨 |
  |              array               |               모두               | 배열이 항상 큰 것으로 판단됨                                 |
  |              object              |               모두               | 객체가 항상 큰 것으로 판단됨                                 |

  ```php
  var_dump(0 < true); // 숫자 0이 boolean false 값으로 변환되어 비교 // bool(true)
  var_dump("123abc" == 123); // 숫자로 시작하는 문자열 "123abc"는 숫자 123으로 변환되어 비교 // bool(true)
  var_dump("_abc" == 123); // 언더스코어(_)로 시작하는 문자열은 숫자 0으로 변환되어 비교 // bool(false)
  var_dump("abc" == 123); // 영문자로 시작하는 문자열은 숫자 0으로 변환되어 비교 // bool(false)
  var_dump("123abc" === 123); // 비교를 위해 값은 문자열에서 숫자로 변환되지만 타입은 그대로 문자열을 유지함 // bool(false)
  
  $arr1 = array("a" => 10);
  $arr2 = array("a" => 5);
  $arr3 = array("a" => 5, "c" => 7);
  
  var_dump($arr1 >= $arr2); // 배열의 길이가 같은 경우 같은key를 가지는 값을 서로 비교 // bool(true)
  var_dump($arr1 >= $arr3); // 배열의 길이가 다른 경우 배열 요소의 수가 적은 쪽이 작다고 판단함 // bool(false)
  var_dump("문자열" < $arr1); // 배열과 다른 타입을 비교하면 항상 배열이 크다고 판단함 // bool(true)
  ```

## 논리 연산자

* 논리 연산자(logical operator)

  * 논리식을 판단함
  * true와 false를 반환함
  * `and`, `or`, `xor`
    * 두 개의 피연산자를 가지는 이항 연산자
    * 피연산자들의 결합 방향 : 왼쪽에서 오른쪽
  * `!`
    * 한 개의 피연산자를 가지는 단항 연산자
    * 피연산자들의 결합 방향 : 오른쪽에서 왼쪽

  | 논리 연산자 | 설명                                                         |
  | :---------: | ------------------------------------------------------------ |
  |     and     | 논리식이 모두 참이면 참을 반환함(AND 연산)                   |
  |     or      | 논리식 중에서 하나라도 참이면 참을 반환함(OR 연산)           |
  |     xor     | 논리식이 서로 다르면 참을 반환함(XOR 연산)                   |
  |     &&      | 논리식이 모두 참이면 참을 반환함(AND 연산)                   |
  |    \|\|     | 논리식 중에서 하나라도 참이면 참을 반환함(OR 연산)           |
  |      !      | 논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함(NOT 연산) |

  * `and`와 `&&` 연산자, `or`와 `||`연산자는 정확히 같은 동작을 하며, 연산자의 우선순위에서만 차이가 발생함

  * truth table

    | A    | B    | A and B (A && B) | A or B (A \|\| B) | A xor B | !A   |
    | :--: | :--: | :--------------- | --------- | :--: | :--: |
    | true | true | true             | true      | false | false |
| true | false | false | true | true | false |
    | false | true | false | true | true | true |
    | false | false | false | false | false | true |
    
    ```php
    $num1 = true;
    $num2 = false;
    
    var_dump($num1 and $num2);      // true and false -> false // bool(false)
    var_dump($num1 or $num2);       // true or false -> true // bool(true)
    var_dump($num1 xor $num2);      // true xor false -> true // bool(true)
    var_dump( (3 < 5) or ("12" > 20) ); // true or false -> true // bool(true)
    ```

## 비트 연산자

* 비트 연산자(bitwise operator)

  * 비트(bit) 단위로 논리 연산을 수행함
  * 비트 단위로 전체 비트를 왼쪽이나 오른쪽으로 이동시킬 때 사용

  | 비트 연산자 | 설명                                                         |
  | :---------: | ------------------------------------------------------------ |
  |      &      | 대응되는 비트가 모두 1이면 1을 반환함(비트 AND 연산)         |
  |     \|      | 대응되는 비트 중에서 하나라도 1이면 1을 반환함(비트 OR 연산) |
  |      ^      | 대응되는 비트가 서로 다르면 1을 반환함(비트 XOR 연산)        |
  |      -      | 비트를 1이면 0으로, 0이면 1로 반전시킴(비트 NOT 연산)        |
  |     <<      | 지정한 수만큼 비트를 전부 왼쪽으로 이동시킴(left shift 연산) |
  |     \>>     | 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴(right shift 연산) |

  * 비트 AND 연산자

    ```
    00001111 & 00010101 => 00000101
    ```

  * 비트 OR 연산자

    ```
    00001111 & 00010101 => 00011111
    ```

  * 비트 XOR 연산자

    ```
    00001111 ^ 00010101 => 00011010
    ```

  * 비트 NOT 연산자

    ```
    ~ 00001111 => 11110000
    ```

  ```php
  $num1 = 15;
  $num2 = 8;
  
  echo "~ 연산자에 의한 결괏값은 ".(~$num1)."입니다.";    // 1의 보수 // ~ 연산자에 의한 결괏값은 -16입니다.
  echo "<< 연산자에 의한 결괏값은 ".($num2<<1)."입니다."; // 곱하기 2 // << 연산자에 의한 결괏값은 16입니다.
  echo ">> 연산자에 의한 결괏값은 ".($num2>>1)."입니다.";     // 나누기 2 // >> 연산자에 의한 결괏값은 4입니다.
  ```

## 기타 연산자

* 삼항 연산자(ternary operator)

  * 세 개의 피연산자를 가지는 조건연산자

  * 문법

    * 조건식의 결과가 true면 return값 1을 반환하고, false이면 return값 2를 반환함

    ```php
    조건식 ? return값1 : return값2
    ```

  ```php
  $num1 = 15;
  $num2 = 8;
  $result = ($num1 > $num2) ? $num1 : $num2;
  
  echo "둘 중에 더 큰수는 {$result}입니다."; // 둘 중에 더 큰수는 15입니다.
  ```

* 문자열 연산자(string operator)

  * 양쪽에 위치한 두 문자열을 연결해주는 연산자
  * `.`
  * `echo()` 함수에서는 쉼표 연산자(`,`)를 이용하여 문자열 연결 가능

  ```php
  $str1 = "HELLO ";
  $str2 = "PHP";
  
  echo "두 문자열을 합친 문자열은 '".($str1.$str2)."'입니다."; // 두 문자열을 합친 문자열은 'HELLO PHP'입니다.
  
  echo $str1, $str2; // HELLO PHP
  ```

* 배열 합집합 연산자(array union operator)

  * 피연산자로 오는 두 배열의 합집합을 반환함

  * `+`

  * 두 개의 피연산자의 key가 동일한 경우 왼쪽 피연산자의 value가 적용됨

    ```php
    $arr1 = array("1st" => "PHP", "2nd" => "MySQL");
    $arr2 = array("1st" => "HTML", "2nd" => "CSS", "3rd" => "JavaScript");
    $arr3 = array("3rd" => "HTML", "4th" => "CSS", "5th" => "MySQL");
    
    $result1 = $arr1 + $arr2; // [PHP, MySQL, JavaScript]
    var_dump($result1);
    $result2 = $arr2 + $arr1; // [HTML, CSS, JavaScript]
    var_dump($result2);
    $result3 = $arr1 + $arr3; // [PHP, MySQL, HTML, CSS, MySQL]
    var_dump($result3);
    ```

* instanceof 연산자

  * 해당 변수가 어떤 class에서 생성된 object인지 확인함
  * 해당 변수가 부모 클래스(parent class)에서 상속받은 클래스인지 확인함
  * 해당 변수가 클래스의 인스턴스(instance)인지 아닌지를 확인함
  * 해당 변수가 인터페이스(interface)로 구현한 클래스의 객체 인스턴스(object instance)인지 아닌지를 확인함

  ```php
  interface Interface01
  
  {
  }
  class Class01
  
  {
  }
  class Class02 extends Class01 implements Interface01
  
  {
  }
  
  /* 어떤 클래스(class)에서 생성된 객체(object)인지를 확인할 때 */
  $var1 = new Class01; // Class01 클래스 객체를 생성함.
  var_dump($var1 instanceof Class01);     // bool(true)
  var_dump($var1 instanceof Class02);     // bool(false)
  
  /* 부모 클래스(parent class)에서 상속받은 클래스인지를 확인할 때 */
  $var2 = new Class02; // Class02 클래스 객체를 생성함.
  var_dump($var2 instanceof Class01);     // bool(true)
  var_dump($var2 instanceof Class02);     // bool(true)
  
  /* 클래스의 인스턴스(instance)인지 아닌지를 확인할 때 */
  $var3 = new Class01; // Class01 클래스 객체를 생성함.
  var_dump(!($var3 instanceof Class02)); // instance가 아님  // bool(true)
  
  /* 인터페이스(interface)로 구현한 클래스의 객체 인스턴스(object instance)인지 아닌지를 확인할 때 */
  $var4 = new Class02; // Class02 클래스 객체를 생성함.
  var_dump($var4 instanceof Class02);     // bool(true)
  var_dump($var4 instanceof Interface01); // bool(true)
  ```

  

 